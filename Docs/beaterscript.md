# BeaterScript – Technical Notes

> **Scope**
> These notes describe, at a low level, how **BeaterScript** interacts with Pokémon Generation 5 game code and how scripts are interpreted by the game engine.
> The focus is on understanding the scripting system and its effects on game behavior, not on distributing copyrighted assets.

---

## Tools Used

* **BeaterScript** — High-level scripting language for Pokémon ROM hacking (Nintendo DS era, primarily Generation 5). Used to manipulate in-game events, NPC behavior, and dialogue logic.
* **FrostGen5Editor** — Tool used to import and apply script patches generated from BeaterScript into the ROM.
* **Emulator / Debugging Tools** — Used to test scripts and observe runtime behavior during gameplay.

---

## 1. BeaterScript Overview

BeaterScript provides a **human-readable abstraction layer** over the Pokémon Gen 5 scripting engine, enabling tasks that would otherwise require low-level HEX editing or manual opcode manipulation.

Typical use cases include:

* NPC movement and interaction logic
* Triggering in-game events (battles, cutscenes, music changes)
* Map behavior modifications (warps, signs, doors)
* Item distribution and trainer encounters

**Execution model:**
BeaterScript source files are **compiled** into binary instructions. The game engine does **not** parse the script text directly; instead, it interprets the compiled opcodes generated by the compiler.

---

## 2. Script Structure

### 2.1 Core Components

A typical BeaterScript script consists of:

1. **Commands** — Engine-recognized actions.
2. **Labels** — Named locations used as jump targets within the script.
3. **Conditionals** — Logic based on flags or variables to control execution flow.
4. **Events / Triggers** — Conditions that determine when a script is executed (NPC interaction, map entry, etc.).

**Execution flow:**

* Commands execute sequentially.
* Control flow can be altered using jump instructions (e.g., `Goto`).

---

## 3. Script Compilation

* Scripts must be compiled into a binary format before being injected into the ROM.
* The compiler translates high-level commands into **numeric opcodes** recognized by the Pokémon scripting engine.
* Command arguments (item IDs, NPC IDs, coordinates, flags) are encoded as numeric values.
* Labels are resolved into **relative jump offsets** during compilation.

> **Warning:** Incorrect compilation, invalid arguments, or misaligned offsets can result in crashes, freezes, or undefined behavior at runtime.

---

## 4. Integration with the ROM

### 4.1 Script Injection via FrostGen5Editor

Typical workflow:

1. Compile the BeaterScript source into a binary patch.
2. Load the patch into FrostGen5Editor.
3. Apply the patch to the ROM.
4. Verify that script size and offsets do not overwrite unrelated data.

### 4.2 Memory and Alignment Considerations

* Scripts are stored as **linear instruction streams**.
* Each command occupies a fixed or variable number of bytes, depending on its arguments.
* Improper padding or incorrect insertion points can corrupt adjacent data structures.

---

## 5. Engine-Level Interpretation

### 5.1 Script Execution Flow

At runtime, the game engine processes scripts as follows:

1. A trigger condition is met (e.g., player interacts with an NPC).
2. A script pointer is resolved.
3. The engine reads the next opcode.
4. Arguments are decoded.
5. The corresponding engine action is executed.

Scripts are always executed **under the control of the game’s event engine** and do not run asynchronously or independently.

---

### 5.2 Common Failure Modes

| Symptom                   | Likely Cause                                    |
| ------------------------- | ----------------------------------------------- |
| Game crash on interaction | Invalid opcode or corrupted instruction stream  |
| Event does not trigger    | Incorrect trigger definition or flag condition  |
| Incorrect NPC movement    | Wrong argument encoding (coordinates or NPC ID) |
| Dialogue mismatch         | Incorrect or missing message ID                 |

---

## 6. Debugging Strategy

Recommended workflow:

1. Write the script in BeaterScript syntax.
2. Compile and apply the patch using FrostGen5Editor.
3. Test behavior in an emulator.
4. Observe runtime behavior and identify incorrect outcomes.
5. Modify **one command at a time** and re-test.

Incremental testing is critical to isolating script-related issues.

---

## 7. Best Practices

* Always keep backups of the ROM before applying script patches.
* Keep scripts **modular and readable**.
* Use labels to structure control flow clearly.
* Validate flag and variable usage to avoid unintended side effects.
* Monitor script size to prevent data overlap.

---

## 8. Modding Ethics and Safety

* Scripts alter behavior but do not redistribute copyrighted assets.
* Intended for educational, research, or personal modding use.
* Avoid sharing ROMs or extracted proprietary data.

---

## 9. Summary

* BeaterScript provides a high-level interface to the Pokémon Gen 5 scripting engine.
* Scripts are compiled into **engine-compatible binary opcodes**.
* Execution is driven by triggers and interpreted sequentially.
* Correct handling of offsets, flags, and arguments is essential.
* Careful debugging and incremental changes lead to predictable results.

Mastery of BeaterScript enables **controlled and reproducible gameplay modifications** without direct low-level editing.

## Legal Notice

This document is intended for educational and research purposes.
No proprietary game assets, binaries, or copyrighted material
are included or distributed.

All trademarks belong to their respective owners.
